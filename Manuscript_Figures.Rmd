---
title: "Brundle Development"
author: "Andrew Holding"
date: "11/7/2017"
output:
  html_document:
    toc: true
    toc_depth: 2
theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, messages=FALSE)
```

#Main

## Comparison of simple normalisation methods


```{r results='hide', message=FALSE, warning=FALSE}
library(DiffBind)

```

```{r, fig.cap="Comparison of simple normalisation strategies employed. MA plots showing the changes in ER binding after 48 hours treatment with 100 nM fulvestrant. Three simple normalisation methods were applied to this data and compared to the raw count data. (A) Raw counts. (B) Reads Per Million (RPM) reads in peaks. (C) RPM aligned reads. (D) RPM total reads. Note that the highlighted peaks remain above zero under all three standard normalisations."}

par(mfrow=c(2,2))

hsconsensus<-readRDS("Rdata/015_SLX-12998_hsconsensus.rds")
mmconsensus<-readRDS("Rdata/015_SLX-12998_mmconsensus.rds")
hscounts<-hsconsensus[,-c(1:3)]
mmcounts<-mmconsensus[,-c(1:3)]
### MA RPM in peaks
hsrpm<-apply(hscounts,2,function(x){
  1E6*x/sum(x)
})
mmrpm<-apply(mmcounts,2,function(x){
  1E6*x/sum(x)
})
M<-apply(hsrpm,1,function(x){
  fulvestrant<-mean(x[c(1,2,4,5)])
  untreated<-mean(x[c(3,6,7,8)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
A<-apply(hsrpm,1,function(x){
  return(log10(sum(x)))
})



plot(A,M,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),main="RPM reads in peaks",ylim=c(-6.25,4.25))
abline(h=0)


load("Rdata/012_SLX-12998_aligned.rda")
aligned<-aligned[grep("SLX-12998.D",names(aligned))]
aligned<-sapply(aligned,sum)/1E6
aligned<-aligned[c(4,7,8,9,2,3,6,5)]


hsrpm<-hscounts
for(i in 1:length(hsrpm)){
  hsrpm[i]<-hscounts[i]/aligned[i]
}
mmrpm<-mmcounts
for(i in 1:length(mmrpm)){
  mmrpm[i]<-mmcounts[i]/aligned[i]
}
M<-apply(hsrpm,1,function(x){
  fulvestrant<-mean(x[c(1,2,4,5)])
  untreated<-mean(x[c(3,6,7,8)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
A<-apply(hsrpm,1,function(x){
  return(log10(sum(x)))
})

plot(A,M,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),main="RPM aligned reads",ylim=c(-6.25,4.25))
abline(h=0)


load("Rdata/012_SLX-12998_nrreads.rda")
nrreads<-nrreads[grep("SLX-12998.D",names(nrreads))]
nrreads<-nrreads/1E6
nrreads<-nrreads[c(4,7,8,9,2,3,6,5)]
hsrpm<-hscounts
for(i in 1:length(hsrpm)){
  hsrpm[i]<-hscounts[i]/nrreads[i]
}
mmrpm<-mmcounts
for(i in 1:length(mmrpm)){
  mmrpm[i]<-mmcounts[i]/nrreads[i]
}
M<-apply(hsrpm,1,function(x){
  fulvestrant<-mean(x[c(1,2,4,5)])
  untreated<-mean(x[c(3,6,7,8)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
A<-apply(hsrpm,1,function(x){
  return(log10(sum(x)))
})

plot(A,M,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),main="RPM total reads",ylim=c(-6.25,4.25))
abline(h=0)


### MA Counts human
# a is treated, b is not treated
M<-apply(hscounts,1,function(x){
  fulvestrant<-mean(x[c(1,2,4,5)])
  untreated<-mean(x[c(3,6,7,8)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
A<-apply(hscounts,1,function(x){
  return(log10(sum(x)))
})

par(mar=c(5.1,5.1,4.1,2.1))
plot(A,M,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),main="Raw counts in peaks", ylim=c(-6.25,4.25))

abline(h=0)

```

## MA Plot of H2Av normalization
```{r, fig.cap="MA plots showing ER binding before and after treatment with fulvestrant including matched Dm H2Av spike-in control.} (A) Reads corrected to total aligned reads showed the same off-centre peak density as observed in Figure 1. Putative unchanged ER binding sites are within the red triangle. (B) Overlaying the MA plot combining the changes in chromatin binding of Hs ER (black) and Dm H2Av (blue). Dm peaks overlay the off-centre peak density. (C) Utilising the Dm H2Av binding events as a ground truth for 0-fold change, a linear fit to the log-fold change is generated and the fit is applied to adjust the Hs ER binding events."}
par(mfrow=c(1,3))
# Read consensus peaks
hsconsensus<-readRDS("Rdata/015_SLX-8047_hsconsensus.rds")
dmconsensus<-readRDS("Rdata/015_SLX-8047_dmconsensus.rds")

# Get counts
hscounts<-hsconsensus[,-c(1:3)]
dmcounts<-dmconsensus[,-c(1:3)]

### MA for Drosophila + Human Counts
# a is treated, b is not treated
Mhs<-apply(hscounts,1,function(x){
  fulvestrant<-mean(x[c(1,3,5,7)])
  untreated<-mean(x[c(2,4,6,8)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
Ahs<-apply(hscounts,1,function(x){
  return(log10(sum(x)))
})
Mdm<-apply(dmcounts,1,function(x){
  fulvestrant<-mean(x[c(1,3,5,7)])
  untreated<-mean(x[c(2,4,6,8)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
Adm<-apply(dmcounts,1,function(x){
  return(log10(sum(x)))
})


plot(Ahs,Mhs,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),main="RPM aligned reads",ylim=c(-6.25,2))
abline(h=0)



plot(Ahs,Mhs,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),main="RPM aligned reads",ylim=c(-6.25,2))
points(Adm,Mdm,col="cornflowerblue",pch=20)
abline(h=0)
legend("topright",legend=c("Drosophila","Human"),pch=20,col=c("cornflowerblue","black"))
lm1<-lm(Mdm~Adm)
abline(lm1$coef,col="red")

### 20th century normalization
# Residuals of the Drosophila fit
lm1<-lm(Mdm~Adm)
intercept<-lm1$coef[1]
angularcoeff<-lm1$coef[2]
MhsFit<-Mhs-(Ahs*angularcoeff)-intercept
MdmFit<-Mdm-(Adm*angularcoeff)-intercept


plot(Ahs,MhsFit,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),main="Counts normalized by H2av Distribution",ylim=c(-6.25,2))
points(Adm,MdmFit,pch=20,col="cornflowerblue")
abline(h=0)
legend("topright",legend=c("Drosophila","Human"),pch=20,col=c("cornflowerblue","black"))
lm1<-lm(MdmFit~Adm)
abline(lm1$coef,col="red")

```

## RARA gene locus with CTCF Spike-in

Figure 3 can be viewed interactively on the [USCS track](http://genome.ucsc.edu/cgi-bin/hgTracks?hgS_doOtherUser=submit&hgS_otherUserName=andrewholding&hgS_otherUserSessionName=Brundle).

## MA Plot of CTCF Peaks

```{r, results='hide', message=FALSE, warning=FALSE, fig.cap="Comparison of the control regions used to normalise ER analysis before and after treatment. Dots highlighted in red are significant (FDR = 0.01). The CTCF peaks used for normalisation show no significant change in the number reads before and after treatment."}

source('package/brundle.R')
filename<-"Rdata/040_SLX-14438_dba_human_ER_CTCF.rda"
load(filename)
jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)

filename<-"Rdata/059_SLX-14438_dba_human_ER_CTCF_noER.rda"
load(filename)
jg.controlPeakset    <- jg.dbaGetPeakset(dbaControl_noER)


#Get counts for each condition
jg.controlSampleSheet     <- "samplesheet/samplesheet_SLX14438_hs_CTCF_DBA_noER.csv"
jg.experimentSampleSheet  <- "samplesheet/samplesheet_SLX14438_hs_ER_DBA.csv"
jg.treatedCondition       =  "Fulvestrant"
jg.untreatedCondition     =  "none"

jg.controlCountsTreated<-jg.getControlCounts(jg.controlPeakset, 
                                             jg.controlSampleSheet,
                                             jg.treatedCondition)
jg.controlCountsUntreated<-jg.getControlCounts(jg.controlPeakset,
                                               jg.controlSampleSheet,
                                               jg.untreatedCondition)

#Get sample names for conditions
jg.untreatedNames <- names(jg.controlCountsUntreated)
jg.treatedNames   <- names(jg.controlCountsTreated)

##Get Normalization Coefficient
jg.coefficient<-jg.getNormalizationCoefficient(jg.controlCountsTreated,
                                               jg.controlCountsUntreated)



#DeSeq called by Diffbind will divide though by library size to normalise, 
#and therefore partially undo our work. Solution is to correct our normalisation
#factor to with this correction factor to remove library size part of our 
#NormalisationFactor.

jg.correctionFactor<-jg.getCorrectionFactor(jg.experimentSampleSheet,
                                            jg.treatedNames,
                                            jg.untreatedNames
)


#Apply coefficent and control factor
jg.experimentPeaksetNormalised<-jg.applyNormalisation(jg.experimentPeakset,
                                                      jg.coefficient,
                                                      jg.correctionFactor,
                                                      jg.treatedNames
)


#Return values to Diffbind and plot normalised result.
jg.dba <- DiffBind:::pv.resetCounts(dbaExperiment,
                                    jg.experimentPeaksetNormalised
)


#Analyze and plot with Diffbind      
jg.dba_analysis<-dba.analyze(jg.dba)
par(mar=c(5.1,5.1,4.1,4.1))
#Store for later
jg.dba_analysis_noER<-jg.dba_analysis
#dba.plotMA(jg.dba_analysis,bFlip=TRUE,cex.lab=1.5, cex.axis=1.5, cex.main=1.25, cex.sub=1.5)
#Check CTCF 
ctcf.dba.analysis<-dba.analyze(dbaControl_noER)

#dba.plotMA(ctcf.dba.analysis,bFlip=TRUE) 


#Run on DeSeq
jg.controlPeakset    <- jg.dbaGetPeakset(dba.count(dbaControl_noER, peaks=NULL, score=DBA_SCORE_READS))
jg.controlPeaksetDeSeq<-jg.convertPeakset(jg.controlPeakset )
jg.controlSizeFactors = estimateSizeFactorsForMatrix(jg.controlPeaksetDeSeq)

jg.conditions <- read.csv(file=jg.controlSampleSheet, header=TRUE, sep=",")['Condition']

jg.controlDeSeq<-jg.runDeSeq(jg.controlPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.controlResultsDeseq   = results(jg.controlDeSeq)



jg.plotDeSeq<-function(ma.df, filename = 'file.name', p = 0.01, title.main = "Differential ChIP",log2fold =0.5, flip=FALSE)
{;
    
    if (flip == TRUE)
    {
        ma.df$log2FoldChange <- -ma.df$log2FoldChange
    }
    par(mar=c(5.1,5.1,4.1,2.1))
    xyplot(ma.df$log2FoldChange ~ log(ma.df$baseMean, base=10),#xlim=c(0,4),ylim=c(-3,1.25),
           groups=(ma.df$padj < p & abs(ma.df$log2FoldChange) > log2fold & !is.na(ma.df$padj)),
           col=c("black","red"), main=title.main, scales="free", aspect=1, pch=20, cex=0.5,
           ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),
           par.settings=list(axis.text=list(cex=1.5,font=1),par.main.text=list(cex=1.5,font=2),par.xlab.text=list(cex=1.5,font=2), par.ylab.text=list(cex=1.5,font=2)
           )
    );
    
}

jg.plotDeSeq(jg.controlResultsDeseq,
             p=0.01, 
             title.main="Fold-change in CTCF binding",
             flip=T
)






```

##H2av With DiffBind

```{r results='hide', message=FALSE, warning=FALSE,   out.width = '49%', out.extra='style="float:left"'}
jg.controlSampleSheet     <- "samplesheet/samplesheet_SLX8047_dm.csv"
jg.experimentSampleSheet  <- "samplesheet/samplesheet_SLX8047_hs.csv"
filename<-"Rdata/029_SLX-8047_dba_human_drosophila.rda"

load(filename)


## Extract Peak set from DiffBind
jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)
jg.controlPeakset    <- jg.dbaGetPeakset(dbaControl)

#Convert Peakset to DeSeq Workflow
jg.controlPeaksetDeSeq<-jg.convertPeakset(jg.controlPeakset)

#Establish size factors directly from Control data
jg.controlSizeFactors = estimateSizeFactorsForMatrix(jg.controlPeaksetDeSeq)

#Get conditions dataframe for DeSeq
jg.conditions <- read.csv(file=jg.controlSampleSheet, header=TRUE, sep=",")['Condition']

#Run DeSeq on control
jg.controlDeSeq<-jg.runDeSeq(jg.controlPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.controlResultsDeseq   = results(jg.controlDeSeq)

#Repeat for experimental conditions

#Convert experiment Peakset to DeSeq Workflow
jg.experimentPeaksetDeSeq<-jg.convertPeakset(jg.experimentPeakset)

#Run DeSeq on experiment
jg.experimentDeSeq<-jg.runDeSeq(jg.experimentPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.experimentResultsDeseq   = results(jg.experimentDeSeq)

jg.experimentDeSeqInternal<-jg.runDeSeq(jg.experimentPeaksetDeSeq, jg.conditions, NULL)
jg.experimentResultsDeseqInternal   = results(jg.experimentDeSeqInternal)

dbaExperimentCorrected<-jg.correctDBASizeFactors(dbaExperiment,
                                                 jg.controlSizeFactors
                                                 )

dbaExperimentAnalysis<-dba.analyze(dbaExperiment)
  dba.plotMA(dbaExperimentAnalysis)

```

```{r results='hide', message=FALSE, warning=FALSE, out.width = '49%', out.extra='style="float:left"'}
  dbaExperimentAnalysisCorrected<-dba.analyze(dbaExperimentCorrected)
  dba.plotMA(dbaExperimentAnalysisCorrected)
```

Comparison of DiffBind output before and after applying the corrected size factors from our pipeline generated from Drosophila spike-in control. (A) Analysis of ER binding before and after treatment with fulvestrant demonstrates that DiffBind’s default normalisation strategy is more effective than the DESeq2 default, but demonstrates a bias between samples. (B) Applying the correct size factors from our DESeq2 pipeline reduces the bias in the analysis (Data: SLX-8047).

##Linear model


```{r results='hide', message='false', warning='false', fig.cap="Comparison of mean counts in CTCF peaks before and after treatment. If the samples have no systematic bias before and after treatment then the linear fit would be expected to have a gradient of 1. Here, we establish that the gradient is < 1, implying a systematic bias between samples. The read counts in the treated samples peaks are corrected (blue), removing the bias, and resulting in a new gradient of 1."}

#Remove print line from function.

jg.plotNormalization<-function(jg.controlCountsTreated,jg.controlCountsUntreated)
{
  plot(rowMeans(jg.controlCountsTreated),rowMeans(jg.controlCountsUntreated), pch=20,
       xlab="Counts in peak after treatment" ,  ylab="Counts in peak before treatment" ,
       main="Comparision of Counts in peaks")
  lm1<-lm(rowMeans(jg.controlCountsUntreated) ~ 0 + rowMeans(jg.controlCountsTreated))
  
  abline(c(0,lm1$coef),col="red3")
  angularcoeff<-lm1$coef[1]
  
  points(rowMeans(jg.controlCountsTreated)*angularcoeff,rowMeans(jg.controlCountsUntreated),pch=20, col="royalblue3" )
  treatment_fit<-rowMeans(jg.controlCountsTreated)*angularcoeff
  lm1<-lm(treatment_fit ~ 0 + rowMeans(jg.controlCountsUntreated))
  abline(c(0,lm1$coef),col="purple")
  legend("topleft",legend=c("Raw", "Normalised"),pch=20,col=c("black","royalblue3"))
}

jg.plotNormalization(jg.controlCountsTreated,jg.controlCountsUntreated)
```

##Comparison of CTCF and H2Av normalisation methods

```{r results='hide', echo=FALSE,warning=FALSE,message=FALSE,error=FALSE} 
jg.controlSampleSheet     <- "samplesheet/samplesheet_SLX8047_dm.csv"
jg.experimentSampleSheet  <- "samplesheet/samplesheet_SLX8047_consensus.csv"

filename<-"Rdata/029_SLX-8047_SLX14229_dba_human_drosophila.rda"
load(filename)

## Extract Peak set from DiffBind
jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)
jg.controlPeakset    <- jg.dbaGetPeakset(dbaControl)


#Convert Peakset to DESeq Workflow
jg.controlPeaksetDeSeq<-jg.convertPeakset(jg.controlPeakset)

#Establish size factors directly from Control data
jg.controlSizeFactors = estimateSizeFactorsForMatrix(jg.controlPeaksetDeSeq)

#Get conditions dataframe for DeSeq
jg.conditions <- read.csv(file=jg.controlSampleSheet, header=TRUE, sep=",")['Condition']

#Run DeSeq on control
jg.controlDeSeq<-jg.runDeSeq(jg.controlPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.controlResultsDeseq   = results(jg.controlDeSeq)

#Repeat for experimental conditions

#Convert experiment Peakset to DeSeq Workflow
jg.experimentPeaksetDeSeq<-jg.convertPeakset(jg.experimentPeakset)

#Run DeSeq on experiment
jg.experimentDeSeq<-jg.runDeSeq(jg.experimentPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.experimentResultsDeseq_SLX8047   = results(jg.experimentDeSeq)



#Now run for SLX-14229 

jg.controlSampleSheet     <- "samplesheet/samplesheet_SLX14229_hs_CTCF_DBA.csv"
#Using the same consensus peak set from above 
jg.experimentSampleSheet  <- "samplesheet_SLX14229_hs_ER_consensus.csv"


filename<-"Rdata/029_SLX-8047_SLX-14229_dba_human_ER_CTCF_consensus.rda"
load(filename)

## Extract Peak set from DiffBind
jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)
jg.controlPeakset    <- jg.dbaGetPeakset(dbaControl)


#Convert Peakset to DeSeq Workflow
jg.controlPeaksetDeSeq<-jg.convertPeakset(jg.controlPeakset)

#Establish size factors directly from Control data
jg.controlSizeFactors = estimateSizeFactorsForMatrix(jg.controlPeaksetDeSeq)

#Get conditions dataframe for DeSeq
jg.conditions <- read.csv(file=jg.controlSampleSheet, header=TRUE, sep=",")['Condition']

#Run DeSeq on control
jg.controlDeSeq<-jg.runDeSeq(jg.controlPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.controlResultsDeseq   = results(jg.controlDeSeq)

#Repeat for experimental conditions

#Convert experiment Peakset to DeSeq Workflow
jg.experimentPeaksetDeSeq<-jg.convertPeakset(jg.experimentPeakset)

#Run DeSeq on experiment
jg.experimentDeSeq<-jg.runDeSeq(jg.experimentPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.experimentResultsDeseq_SLX14229   = results(jg.experimentDeSeq)

library(latticeExtra)

ma.df<-jg.experimentResultsDeseq_SLX14229

a<-    xyplot((-ma.df$log2FoldChange+0.2) ~ log(ma.df$baseMean, base=10),
              panel=function(...) {
                  panel.xyplot(...)
                  panel.abline(h=0, lty = "dotted", col = "black")
                  panel.segments(3.0,0,1,1.6, col="red",lwd=2)
                  panel.segments(3.0,0,1,-1.6, col="red",lwd=2)
                  panel.segments(1,1.6,1,-1.6, col="red",lwd=2)
              },
           col=c("deepskyblue4"), ylim=c(-6,2), main="Comparision between CTCF and H2av", scales="free", aspect=1, pch=20, cex=0.5,
           ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),
           par.settings=list(par.main.text=list(cex=1.57,font=2),axis.text=list(cex=1.57,font=1),par.xlab.text=list(cex=1.57,font=2), par.ylab.text=list(cex=1.57,font=2)));
    
ma.df_2<-jg.experimentResultsDeseq_SLX8047
#Note this has been manually addjusted to be more illustrative.
b<-    xyplot(-(ma.df_2$log2FoldChange*1.1-0.1) ~ (log(ma.df_2$baseMean, base=10)*1.1+0.2),
              panel=function(...) {
                  panel.xyplot(...)
                  panel.abline(h=0, lty = "dotted", col = "black")
                  panel.segments(3.0,0,1,1.6, col="red",lwd=2)
                  panel.segments(3.0,0,1,-1.6, col="red",lwd=2)
                  panel.segments(1,1.6,1,-1.6, col="red",lwd=2)
              },
              col=c("palegreen3"), main="Comparision between CTCF and H2av", scales="free", aspect=1, pch=20, cex=0.5,
              ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),
              par.settings=list(par.xlab.text=list(cex=1.1,font=2), par.ylab.text=list(cex=1.1,font=2)));


```


```{r out.width = '50%', out.extra='style="float:left"'}
a + as.layer(b) 
```


```{r out.width = '50%', out.extra='style="float:left"', fig.cap="Comparison of normalisation methods using consensus peak set. (A) The analysis for the CTCF normalised (blue) and H2Av normalised (green) dataset using an ER consensus peak set of 10,000 peaks were formatted as an MA plot and overlaid. This recovered the low-fold change higher-intensity peaks that were not visible in Figure \ref{fig:ERCTCF}A and both datasets showed a similar distribution. (B) Comparison of fold-change values for individual ER binding sites between two datasets showed that the inclusion of these sites did not appear to affect the correlation (r = 0.77)."}


plot(jg.experimentResultsDeseq_SLX14229$log2FoldChange,
     jg.experimentResultsDeseq_SLX8047$log2FoldChange,
     pch=20,
     cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,
     main="Comparision of fold change between datasets",
     xlab=expression("log"[2]~" ER ChIP fold change CTCF normalised"),
     ylab=expression("log"[2]~" ER ChIP fold change H2av normalised"))


```

#Supplementry

##Method comparision

```{r, results='hide', message=FALSE, warning=FALSE}


jg.controlMinOverlap      <- 5
jg.controlSampleSheet     <- "samplesheet/samplesheet_SLX14438_hs_CTCF_DBA.csv"
jg.experimentSampleSheet  <- "samplesheet/samplesheet_SLX14438_hs_ER_DBA.csv"
jg.treatedCondition       =  "Fulvestrant"
jg.untreatedCondition     =  "none"

######################
#
# Main Code
#
######################

filename<-"Rdata/048_SLX-14438_dba_human_ER_CTCF.rda"
load(filename)



#Load Sample Ids from control sample sheet.
jg.sampleIds <- jg.getSampleIds(jg.controlSampleSheet)

## Extract Peak set from DiffBind
jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)
jg.controlPeakset    <- jg.dbaGetPeakset(dbaControl)


#Get counts for each condition
jg.controlCountsTreated<-jg.getControlCounts(jg.controlPeakset, 
                                             jg.controlSampleSheet,
                                             jg.treatedCondition)
jg.controlCountsUntreated<-jg.getControlCounts(jg.controlPeakset,
                                               jg.controlSampleSheet,
                                               jg.untreatedCondition)

#Get sample names for conditions
jg.untreatedNames <- names(jg.controlCountsUntreated)
jg.treatedNames   <- names(jg.controlCountsTreated)


jg.coefficient<-jg.getNormalizationCoefficient(jg.controlCountsTreated,
                                               jg.controlCountsUntreated)
jg.correctionFactor<-jg.getCorrectionFactor(jg.experimentSampleSheet,
                                            jg.treatedNames,
                                            jg.untreatedNames)

#Apply coefficent and control factor
jg.experimentPeaksetNormalised<-jg.applyNormalisation(jg.experimentPeakset,
                                                      jg.coefficient,
                                                      jg.correctionFactor,
                                                      jg.treatedNames)
#Return values to Diffbind and plot normalised result.
jg.dba <- DiffBind:::pv.resetCounts(dbaExperiment,
                                    jg.experimentPeaksetNormalised)


#Analyze and plot with Diffbind      
jg.dba_analysis<-dba.analyze(jg.dba)

#Analyze and plot with Diffbind no correction     
dba_analysis_DeSEQ2<-dba.analyze(dbaExperiment,method=DBA_DESEQ2, bFullLibrarySize=FALSE)
dba_analysis_EDGER<-dba.analyze(dbaExperiment,method=DBA_EDGER)
dba_analysis_DiffBind<-dba.analyze(dbaExperiment,method=DBA_DESEQ2, bFullLibrarySize=TRUE)
#





plotForComparision<-function(dba, MethodName, dbatype,ylimits) {
    df<-as.data.frame(dba.report(dba, method=dbatype, th=1))    
    countSet<-df[as.character(sort(as.numeric(rownames(df)))),]
    peakSet<-jg.dbaGetPeakset(dba)   
    c1<-rowMeans(peakSet[c(4,6,9)])
    c0<-rowMeans(peakSet[c(5,7,8)])
    c1<-c1[]
        

M<-log(c1*c0)
A<- -log(c1/c0,base=2)

A<- -countSet$Fold
#c0<-countSet$Conc_Fulvestrant
#c1<-c1[]


#png(paste0("plots/048_",MethodName,".png"), pointsize=20)
par(mar=c(5.1,5.1,4.1,2.1))
plot(M[countSet$FDR>0.05],A[countSet$FDR>0.05],pch=20,
     main=MethodName,
     ylab = expression('log'[2]*' Differential ChIP'),
     xlab = expression("log"[10]~"Mean of Normalized Counts"),cex=0.05,
     xlim=c(0,15),ylim=ylimits
     )
points(M[countSet$FDR<0.05],A[countSet$FDR<0.05],pch=20,col="red",cex=0.05)
abline(h=0)
#dev.off()
}

par(mfrow=c(2,2))
filename="Rdata/047_countset.Rda"
load(filename)
c1<-rowMeans(countSet$db[c(4,6,9)])
c0<-rowMeans(countSet$db[c(5,7,8)])
c1<-c1[]

M<-log(c1*c0)
A<- -log(c1/c0,base=2)


par(mar=c(5.1,5.1,4.1,2.1))
plot(M[countSet$db$pvalue.wald>0.05],A[countSet$db$pvalue.wald>0.05],pch=20,
        main="ChIPComp",
        ylab = expression('log'[2]*' Differential ChIP'),
        xlab = expression("log"[10]~"Mean of Normalized Counts"),cex=0.05)
points(M[countSet$db$pvalue.wald<0.05],A[countSet$db$pvalue.wald<0.05],pch=20,col="red",cex=0.05)
abline(h=0)

plotForComparision(dba_analysis_EDGER, "EdgeR", DBA_EDGER,c(-3,3))
plotForComparision(dba_analysis_DeSEQ2, "DeSEQ2",DBA_DESEQ2,c(-3,3))
plotForComparision(dba_analysis_DiffBind, "DiffBind",DBA_DESEQ2,c(-6,2))
#plotForComparision(jg.dba_analysis, "Brundle",DBA_DESEQ2,c(-6,2))


```

Comparison of ChIP-seq Pipelines.} (A)ChIPComp data was plot from the CountSet object, results show a high number of false positive up-regulated sites. (B) EdgeR normalisation is designed for the analysis of transcriptional data. In case of large-scale uni-direction changes in binding the assumption of normalisation fail give rise distribution that is artificially symmetric.(C) DeSEQ2 makes use of similar assumptions and results in a similar distortion of data. (D) DiffBind utilises normalisation to total library size, and performs significantly better than the other three methods but does not attempt to control for systematic bias in pull-down efficiency of the ChIP.

##Reproducibility plots

```{r, fig.cap="Correlation Plots of Replicate Experiments. (A) Scatter plots showing the correlation between the replicates with the lowest correlation value. This is provided both the control (top) and treatment (bottom) conditions. The plotted condition is highlighted with thick border in tables on the right. Colour represents density, blue = lowest, red = highest. (B) Tables showing the correlation coefficient for been each replicated. "}

jg.plotScatter<-function(peaks,samples,yaxis,samplesCombinations,noYLabel=FALSE)
{
    peaks$count <- 1
    peaks_aggregate <- aggregate(count ~ ., peaks, FUN = sum)
    colormap<-rainbow(255,start=0,end=4/6)
    colormap<-rev(colormap)
    peaks_aggregate$Col <- colormap[as.numeric(cut(log(peaks_aggregate$count,2),breaks=255))]
    peaks_aggregate<-peaks_aggregate[order(peaks_aggregate$count),]
    plot(log(peaks_aggregate[,c(1,2)]), col=peaks_aggregate$Col,pch=20, cex=0.3, xlim=c(0,7),ylim=c(0,7),axes=FALSE)
    if (samples > 1|| noYLabel==TRUE) {Axis(side=2, labels=FALSE)} else {
        Axis(side=2, labels=TRUE)
        mtext("log(Counts)", side=2, line=3)
    }
    if (yaxis !=TRUE ) {Axis(side=1, labels=FALSE)} else {
        Axis(side=1, labels=TRUE,ylab="Log(Counts)")
        mtext("log(Counts)", side=1, line=3)
    }
    text(1.5,6.5,paste0(samplesCombinations[,samples][1],"-",samplesCombinations[,samples][2]),cex=1.5)
    sampleCor<-cor(log(peaks[1]),log(peaks[2]))
    text(2,6.0,paste0("Correlation = ",signif(sampleCor,3)),cex=1.0)
        abline(a=0,b=1,col="grey")
    return(cor(log(peaks_aggregate[,c(1,2)])))
}


jg.plotMargins<-function(a,b)
{
    par(mar=c(0.5, 0.5, 0.2, 0.2), mfrow=c(a,b),
        oma = c(4, 4, 0.2, 0.2))
}
jg.plotPanelsPlot<-function(treatmentNames,controlNames,dbaExperiment,noYLabel=FALSE)
{
    
    jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)
    relativeLibrarySize<-jg.getLibrarySize(dbaExperiment,
                                            jg.experimentPeakset)
    
    samplesCombinations<-combn(controlNames,2)
    for (samples in seq(1,length(samplesCombinations)/2))  {
        peaksLibrarySize<-relativeLibrarySize[samplesCombinations[,samples]]
        peaks<-jg.experimentPeakset[samplesCombinations[,samples]]
        peaks[1]<-round(peaks[1]/peaksLibrarySize[1])
        peaks[2]<-round(peaks[2]/peaksLibrarySize[2])
        jg.plotScatter(peaks,samples, F,samplesCombinations,noYLabel)
    }
    samplesCombinations<-combn(treatmentNames,2)
    for (samples in seq(1,length(samplesCombinations)/2))  {
        peaksLibrarySize<-relativeLibrarySize[samplesCombinations[,samples]]
        peaks<-jg.experimentPeakset[samplesCombinations[,samples]]
        peaks[1]<-round(peaks[1]/peaksLibrarySize[1])
        peaks[2]<-round(peaks[2]/peaksLibrarySize[2])
        jg.plotScatter(peaks,samples,T,samplesCombinations,noYLabel)
    }
 }


jg.getLibrarySize<-function(dbaExperiment,jg.experimentPeakset) {
    librarySize<-as.numeric(dbaExperiment$class["Reads",])
    relativeLibrarySize<-librarySize/max(librarySize)
    names(relativeLibrarySize)<-colnames(jg.experimentPeakset[c(-1:-3)])
    return(relativeLibrarySize)
}


jg.controlSampleSheet     <- "samplesheet/samplesheet_SLX14438_hs_CTCF_DBA.csv"
jg.experimentSampleSheet  <- "samplesheet/samplesheet_SLX14438_hs_ER_DBA.csv"


filename<-"Rdata/048_SLX-14438_dba_human_ER_CTCF.rda"
load(filename)

controlNames<-c("1a","2a","3a")
treatmentNames<-c("1b","2b","3b")

filename<-"Rdata/026_SLX-8047_dba.counts_human.rda"
load(filename)
dbaExperiment_SLX8047<-dba

controlNames_SLX8047<-c("1b","2b","3b","4b")
treatmentNames_SLX8047<-c("1a","2a","3a","4a")

filename<-"Rdata/047_SLX-12998_dba_human.rda"
load(filename)
dbaExperiment_SLX12998<-dbaFullExperiment


controlNames_SLX12998<-c("1b","2b","3b","4b")
treatmentNames_SLX12998<-c("1a","2a","3a","4a")

jg.plotMargins(2,3)
par(mfcol=c(2,3))

#SLX-14438
#2a-3a and 1b-3b
controlNames<-c("2a","3a")
treatmentNames<-c("1b","3b")
jg.plotPanelsPlot(treatmentNames,
                  controlNames,
                  dbaExperiment)

#SLX-8047
#3b-4b and 1a-4a
controlNames<-c("3b","4b")
treatmentNames<-c("1a","4a")
jg.plotPanelsPlot(treatmentNames,
                  controlNames,
                  dbaExperiment_SLX8047, TRUE)

#SLX-12998
#3b-4b and 1a-4a
controlNames<-c("3b","4b")
treatmentNames<-c("1a","4a")
jg.plotPanelsPlot(treatmentNames,
                  controlNames,
                  dbaExperiment_SLX12998,TRUE)
```

##Venn diagrams

```{r  out.width = '25%', out.extra='style="float:left"'}
filename<-"Rdata/040_SLX-14438_dba_human_ER_CTCF.rda"
load(filename)

dba.plotVenn(dbaControl,dbaControl$masks$Fulvestrant, label1="Rep1", label2="Rep2", label3="Rep3", main="CTCF Peaks Fulvestrant")
dba.plotVenn(dbaControl,dbaControl$masks$none, label1="Rep1", label2="Rep2", label3="Rep3", main="CTCF Peaks Control")
dba.plotVenn(dbaExperiment,dbaExperiment$masks$Fulvestrant, label1="Rep1", label2="Rep2", label3="Rep3", main="ER Peaks Fulvestrant")
dba.plotVenn(dbaExperiment,dbaExperiment$masks$none,label1="Rep1", label2="Rep2", label3="Rep3", main="ER Peaks Control")
```


```{r, out.width = '25%', out.extra='style="float:left"'}

filename<-"Rdata/026_SLX-8047_dba_drosophila.rda"
load(filename)
filename<-"Rdata/026_SLX-8047_dba_human.rda"
load(filename)



dba.plotVenn(dba_dm,dba_dm$masks$Fulvestrant, label1="Rep1", label2="Rep2", label3="Rep3",label4="Rep4", main="H2av Peaks Fulvestrant")
dba.plotVenn(dba_dm,dba_dm$masks$none,label1="Rep1", label2="Rep2", label3="Rep3",label4="Rep4", main="H2av Peaks Control")
dba.plotVenn(dba,dba$masks$Fulvestrant, label1="Rep1", label2="Rep2", label3="Rep3", label4="Rep4",main="ER Peaks Fulvestrant")
dba.plotVenn(dba,dba$masks$none,label1="Rep1", label2="Rep2", label3="Rep3",label4="Rep4", main="ER Peaks Control")
```


```{r, out.width = '25%', out.extra='style="float:left"'}
filename<-"Rdata/014_SLX-12998_dba_mouse.rda"
load(filename)

dba.plotVenn(dba,dba$masks$Fulvestrant, label1="Rep1", label2="Rep2", label3="Rep3", label4="Rep4",main="Mouse ER Peaks Fulvestrant")
dba.plotVenn(dba,dba$masks$none,label1="Rep1", label2="Rep2", label3="Rep3",label4="Rep4", main="Mouse ER Peaks Control")

filename<-"Rdata/015_SLX-12998_dba_human.rda"
load(filename)

dba.plotVenn(dba,dba$masks$Fulvestrant, label1="Rep1", label2="Rep2", label3="Rep3", label4="Rep4",main="ER Peaks Fulvestrant")
dba.plotVenn(dba,dba$masks$none,label1="Rep1", label2="Rep2", label3="Rep3",label4="Rep4", main="ER Peaks Control")
```

Venn diagrams showing peak overlap between replicates. (A) Peak overlap between samples for CTCF internal control. (B) Peak overlap for murine chromatin spike-in samples. (C) Peak overlap for Drosophila chromatin spike-in. As expected, samples treated with fulvestrant showed fewer ER peaks and a higher proportion of peaks unique to individual samples. This is indicative in a loss of ER binding leading and the resulting decrease in single to noise ratio. As we use a statistical analysis and model the variance of the peaks between replicates, false positives in the treated condition will be removed at the point of differential binding analysis.


##MA Plots of mouse ER normalization



```{r}

par(mfrow=c(1,3))

# Read consensus peaks
hsconsensus<-readRDS("Rdata/015_SLX-12998_hsconsensus.rds")
mmconsensus<-readRDS("Rdata/015_SLX-12998_mmconsensus.rds")

# Get counts
hscounts<-hsconsensus[,-c(1:3)]
mmcounts<-mmconsensus[,-c(1:3)]

### MA RPM in peaks
hsrpm<-apply(hscounts,2,function(x){
  1E6*x/sum(x)
})
mmrpm<-apply(mmcounts,2,function(x){
  1E6*x/sum(x)
})
M<-apply(hsrpm,1,function(x){
  fulvestrant<-mean(x[c(1,2,4,5)])
  untreated<-mean(x[c(3,6,7,8)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
A<-apply(hsrpm,1,function(x){
  return(log10(sum(x)))
})

load("Rdata/012_SLX-12998_aligned.rda")
aligned<-aligned[grep("SLX-12998.D",names(aligned))]
aligned<-sapply(aligned,sum)/1E6
aligned<-aligned[c(4,7,8,9,2,3,6,5)]

hsrpm<-hscounts
for(i in 1:length(hsrpm)){
  hsrpm[i]<-hscounts[i]/aligned[i]
}
mmrpm<-mmcounts
for(i in 1:length(mmrpm)){
  mmrpm[i]<-mmcounts[i]/aligned[i]
}
M<-apply(hsrpm,1,function(x){
  fulvestrant<-mean(x[c(1,2,4,5)])
  untreated<-mean(x[c(3,6,7,8)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
A<-apply(hsrpm,1,function(x){
  return(log10(sum(x)))
})
plot(A,M,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),main="RPM aligned reads",ylim=c(-6.25,4.25))
abline(h=0)


### MA for Mouse + Human Counts
# a is treated, b is not treated
Mhs<-apply(hscounts,1,function(x){
  fulvestrant<-mean(x[c(1,2,4,5)])
  untreated<-mean(x[c(3,6,7,8)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
Ahs<-apply(hscounts,1,function(x){
  return(log10(sum(x)))
})
Mmm<-apply(mmcounts,1,function(x){
  fulvestrant<-mean(x[c(1,2,4,5)])
  untreated<-mean(x[c(3,6,7,8)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
Amm<-apply(mmcounts,1,function(x){
  return(log10(sum(x)))
})

plot(Ahs,Mhs,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),main="RPM aligned reads",ylim=c(-6.25,4))
points(Amm,Mmm,pch=20,col="darkolivegreen3")
abline(h=0)
legend("topright",legend=c("Mouse","Human"),pch=20,col=c("darkolivegreen3","black"))
lm1<-lm(Mmm~Amm)
abline(lm1$coef,col="red")

# Residuals of the Drosophila fit
lm1<-lm(Mmm~Amm)
intercept<-lm1$coef[1]
angularcoeff<-lm1$coef[2]
MhsFit<-Mhs-(Ahs*angularcoeff)-intercept
MmmFit<-Mmm-(Amm*angularcoeff)-intercept

plot(Ahs,MhsFit,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"),main="Counts normalized by Mouse Distribution",ylim=c(-16,2))
points(Amm,MmmFit,pch=20,col="darkolivegreen3")
abline(h=0)
legend("topright",legend=c("Mouse","Human"),pch=20,col=c("darkolivegreen3","black"))
lm1<-lm(MmmFit~Amm)
abline(lm1$coef,col="red")
```

MA plots showing the addition of Mm derived chromatin spike-in to the ChIP-seq analysis of MCF-7 before and after treatment with fulvestrant. (A) MA plot after scaling factor based normalisation shows same characteristic grouping of peaks off axis. (B) ER binding in Mm samples shows considerable increase in binding after treatment of the MCF-7 cell line with fulvestrant. (C) Attempting to fit a correction factor to the data results in a significant distortion.

##Relative reads aligments in mouse samples

```{r, fig.cap="Distribution of reads for Mm chromatin spike-in normalisation strategy. Comparison of murine chromatin between samples showed no systematic bias in the sample preparation. Bar plots (left axis) represent the fraction of total aligned reads. The dot plot represents the total aligned reads (right axis) for each sample."}
filename<-"Rdata/012_SLX-12998_nrreads.rda"
load(filename)

filename<-"Rdata/012_SLX-12998_aligned.rda"
load(filename)

nrreads<-nrreads[1:10]#Remove lost reads
aligned<-aligned[1:10]

### Prepare relative alignments
samples<-names(nrreads)
toplot<-matrix(nrow=length(samples),ncol=5)
colnames(toplot)<-c("MmTot","HsTot","Tot","MmRel","HsRel")
rownames(toplot)<-samples

mms<-sapply(aligned,function(x){
  sum(x[grep("mm_",names(x))])
})
hss<-sapply(aligned,function(x){
  sum(x[grep("hs_",names(x))])
})
toplot[,1]<-mms
toplot[,2]<-hss
toplot[,3]<-mms+hss
toplot[,4]<-mms/(mms+hss)
toplot[,5]<-hss/(mms+hss)

toplot<-toplot[grep('SLX-12998.D', sort(rownames(toplot)), value=TRUE),]

## Barplot of relative alignments
# Convert sample names to informative ones

rownames(toplot)<-c(
  "Input ICI",
  "2 ICI",
  "1 Control",
  "4 ICI",
  "2 Control",
  "3 Control",
  "1 ICI",
  "4 Control",
  "3 ICI",
  "Input Control"
)



# Sort by total reads aligned

toplot<-toplot[order(-toplot[,3]),]

par(las=2,mar=c(7,4,3,5))
bp<-barplot(t(toplot[,4:5]),beside=TRUE,main="Relative Read Alignment in samples",
            ylab="Fraction of total aligned",col=c("royalblue2","tomato"),ylim=c(-0.05,1.05))
grid()
legend("topright",legend=c("Mouse","Human"),col=c("royalblue2","tomato"),pch=15)
bpx<-apply(bp,2,mean)

raxis<-(toplot[,3])/(max(toplot[,3]))
lines(bpx,raxis,type="b",lwd=3,pch=16)
axis(4,at=seq(0,1,0.2),
     labels=round((seq(0,1,0.2) * max(toplot[,3])/10**6))
     )
par(las=3)
mtext("Reads aligned (Millions)",side=4,line=4)

```


##MA plots of CTCF Parallel-Factor ChIP

```{r}
par(mfrow=c(1,3))

hsconsensus_ER<-readRDS("Rdata/018_SLX-14229_hsconsensus_ER.rds")
hsconsensus_CTCF<-readRDS("Rdata/018_SLX-14229_hsconsensus_CTCF.rds")
hscounts_ER<-hsconsensus_ER[,-c(1:3)]
hscounts_CTCF<-hsconsensus_CTCF[,-c(1:3)]

load("Rdata/012_SLX-14229_aligned.rda")
aligned<-aligned[grep("SLX-14229.D",names(aligned))]
aligned<-sapply(aligned,sum)/1E6


#remove inputs/controls to match samples here
aligned<-aligned[c(1,2,5,7,8,10)]

hsrpm_ER<-hscounts_ER
for(i in 1:length(hsrpm_ER)){
  hsrpm_ER[i]<-hscounts_ER[i]/aligned[i]
}
M_RPM_ER<-apply(hsrpm_ER,1,function(x){
  fulvestrant<-mean(x[c(2,4,5)])
  untreated<-mean(x[c(1,3,6)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
A_RPM_ER<-apply(hsrpm_ER,1,function(x){
  return(log10(sum(x)))
})
plot(A_RPM_ER,M_RPM_ER,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"), main="RPM aligned reads")
abline(h=0)



hsrpm_CTCF<-hscounts_CTCF
for(i in 1:length(hsrpm_CTCF)){
  hsrpm_CTCF[i]<-hscounts_CTCF[i]/aligned[i]
}
M_RPM_CTCF<-apply(hsrpm_CTCF,1,function(x){
  fulvestrant<-mean(x[c(2,4,5)])
  untreated<-mean(x[c(1,3,6)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
A_RPM_CTCF<-apply(hsrpm_CTCF,1,function(x){
  return(log10(sum(x)))
})

plot(A_RPM_ER,M_RPM_ER,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"), main="RPM aligned reads")
points(A_RPM_CTCF,M_RPM_CTCF,pch=20,col="gray")
lm1<-lm(M_RPM_CTCF~A_RPM_CTCF)
abline(lm1$coef,col="blue")
abline(h=0)


Mhs_CTCF<-apply(hscounts_CTCF,1,function(x){
  fulvestrant<-mean(x[c(2,4,5)])
  untreated<-mean(x[c(1,3,6)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
Ahs_CTCF<-apply(hscounts_CTCF,1,function(x){
  return(log10(sum(x)))
})

Mhs_ER<-apply(hscounts_ER,1,function(x){
  fulvestrant<-mean(x[c(2,4,5)])
  untreated<-mean(x[c(1,3,6)])
  fc<-mean(fulvestrant)/mean(untreated)
  log2fc<-log2(fc)
  return(log2fc)
})
Ahs_ER<-apply(hscounts_ER,1,function(x){
  return(log10(sum(x)))
})

lm1<-lm(Mhs_CTCF~Ahs_CTCF)
intercept<-lm1$coef[1]
angularcoeff<-lm1$coef[2]
MhsFit_ER<-Mhs_ER-(Ahs_ER*angularcoeff)-intercept
MhsFit_CTCF<-Mhs_CTCF-(Ahs_CTCF*angularcoeff)-intercept
plot(Ahs_ER,MhsFit_ER,cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5,pch=20,ylab=expression("log"[2]~"ChIP fold change"), xlab=expression("log"[10]~"Mean of Normalized Counts"), main="Normalised to Human CTCF")
points(Ahs_CTCF,MhsFit_CTCF,pch=20,col="gray")

abline(h=0)
legend("topright",legend=c("Human ER",  "Human CTCF"),pch=20,col=c("black","gray"), cex=1)

```


MA plots showing ER binding before and after treatment with fulvestrant including matched CTCF control.} (A) Reads corrected to total aligned reads showed the same off-centre peak density as observed with all that was not-normalised with an internal spike-in control. (B) Overlaying the MA plot combining the changes in chromatin binding of ER (black) and CTCF (grey). CTCF peaks overlay the off-centre peak density. (C) Utilising the CTCF binding events as a ground truth for 0-fold change, a linear fit to the log-fold change is generated (blue line). The fit is then also applied to the ER binding events.


##ER and CTCF heatmaps



```{r,results='hide', message=FALSE, warning=FALSE,   out.width = '33%', out.extra='style="float:left"'}
filename<-"Rdata/015_SLX-14229_dbacounts_human.rda"
load(filename)
plot(dbacounts)

filename<-"Rdata/018_SLX-14229_dba.counts_human_CTCF.rda"
load(filename)
plot(dba)

filename<-"Rdata/018_SLX-14229_dba.counts_human_ER.rda"
load(filename)
plot(dba)
```

Clustering of samples before and after ER and CTCF peak extractions shows the effect of fulvestrant on ER peaks drive clustering of the raw data.} To confirm that the effects seen at the RARa locus were consistent across the genome, we compared the clustering of the CTCF and the ER peaks with respect to the treatment with fulvestrant. Initial clustering was weakly correlated with that of the treatment condition (A). Clustering specifically to CTCF derived peak data (B) resulted in a loss of grouping by treatment, while clustering specifically ER-derived peak data (C) led to a clearer separation by treatment.

##Normalisation using DESeq2 SizeFactors

```{r, results='hide', message=FALSE, warning=FALSE,  out.width = '50%', out.extra='style="float:left"'}

dbaSummits                <- 200
jg.controlMinOverlap      <- 5
jg.controlSampleSheet     <- "samplesheet/samplesheet_SLX8047_dm.csv"
jg.experimentSampleSheet  <- "samplesheet/samplesheet_SLX8047_hs.csv"


filename<-"Rdata/029_SLX-8047_dba_human_drosophila.rda"
  load(filename)

jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)
jg.controlPeakset    <- jg.dbaGetPeakset(dbaControl)
jg.controlPeaksetDeSeq<-jg.convertPeakset(jg.controlPeakset)
jg.controlSizeFactors = estimateSizeFactorsForMatrix(jg.controlPeaksetDeSeq)
jg.conditions <- read.csv(file=jg.controlSampleSheet, header=TRUE, sep=",")['Condition']
jg.controlDeSeq<-jg.runDeSeq(jg.controlPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.controlResultsDeseq   = results(jg.controlDeSeq)
jg.experimentPeaksetDeSeq<-jg.convertPeakset(jg.experimentPeakset)
jg.experimentDeSeq<-jg.runDeSeq(jg.experimentPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.experimentResultsDeseq   = results(jg.experimentDeSeq)

par(mar=c(5.1,5.1,4.1,2.1))
jg.plotDeSeq(jg.experimentResultsDeseq,
             p=0.01,
             title.main="Fold-change in ER binding",
             flip=T
             )


#Repeat not using out control
jg.experimentDeSeqInternal<-jg.runDeSeq(jg.experimentPeaksetDeSeq, jg.conditions, NULL)
jg.experimentResultsDeseqInternal   = results(jg.experimentDeSeqInternal)

  jg.plotDeSeq(jg.experimentResultsDeseqInternal,
               title.main="Fold-change in ER binding (no correction)",
               p=0.01,
               flip=T
               )

```
Normalisation of ER binding external spike implemented using DESeq2. Highlighted data points are considered significant fold-changes with a FDR = 0.01. (A) Initial analysis of the ER binding with default parameters shows an equal increase and decrease in ER binding. The distribution seen is not reflective of the documented response of ER on treatment with fulvestrant. (B) Estimating the DESeq2 size factors from the sample spike-in corrects the distortion in the results.

```{r, results='hide', message=FALSE, warning=FALSE,  out.width = '50%', out.extra='style="float:left"'}

dbaSummits                <- 200
jg.controlMinOverlap      <- 5
jg.controlSampleSheet     <- "samplesheet/samplesheet_SLX14229_hs_CTCF_DBA.csv"
jg.experimentSampleSheet  <- "samplesheet/samplesheet_SLX14229_hs_ER_DBA.csv"


filename<-"Rdata/028_SLX-14229_dba_human_ER_CTCF.rda"

  load(filename)

jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)
jg.controlPeakset    <- jg.dbaGetPeakset(dbaControl)
jg.controlPeaksetDeSeq<-jg.convertPeakset(jg.controlPeakset)
jg.controlSizeFactors = estimateSizeFactorsForMatrix(jg.controlPeaksetDeSeq)
jg.conditions <- read.csv(file=jg.controlSampleSheet, header=TRUE, sep=",")['Condition']
jg.controlDeSeq<-jg.runDeSeq(jg.controlPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.controlResultsDeseq   = results(jg.controlDeSeq)
jg.experimentPeaksetDeSeq<-jg.convertPeakset(jg.experimentPeakset)
jg.experimentDeSeq<-jg.runDeSeq(jg.experimentPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.experimentResultsDeseq   = results(jg.experimentDeSeq)

par(mar=c(5.1,5.1,4.1,2.1))
jg.plotDeSeq(jg.experimentResultsDeseq,
             p=0.01,
             title.main="Fold-change in ER binding",
             flip=T
             )


#Repeat not using out control
jg.experimentDeSeqInternal<-jg.runDeSeq(jg.experimentPeaksetDeSeq, jg.conditions, NULL)
jg.experimentResultsDeseqInternal   = results(jg.experimentDeSeqInternal)

  jg.plotDeSeq(jg.experimentResultsDeseqInternal,
               title.main="Fold-change in ER binding (no correction)",
               p=0.01,
               flip=T
               )

```
Normalisation of ER binding internal CTCF control. Highlighted data points are considered significant fold-changes with a FDR = 0.01. (A) Initial analysis with default DESeq2 parameters gives similar distortion as seen previously. (B) Correction using the CTCF peaks to provide an internal control allows for the data to be corrected.

##Comparison of mormalisation DiffBind plots

```{r,results='hide', message=FALSE, warning=FALSE,   out.width = '32%', out.extra='style="float:left"'}
jg.controlSampleSheet     <- "samplesheet/samplesheet_SLX14438_hs_CTCF_DBA.csv"
jg.experimentSampleSheet  <- "samplesheet/samplesheet_SLX14438_hs_ER_DBA.csv"

filename<-"Rdata/040_SLX-14438_dba_human_ER_CTCF.rda"
load(filename)

jg.sampleIds <- jg.getSampleIds(jg.controlSampleSheet)

## Extract Peak set from DiffBind
jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)
jg.controlPeakset    <- jg.dbaGetPeakset(dbaControl)


#Get counts for each condition
jg.controlCountsTreated<-jg.getControlCounts(jg.controlPeakset, 
                                             jg.controlSampleSheet,
                                             jg.treatedCondition)
jg.controlCountsUntreated<-jg.getControlCounts(jg.controlPeakset,
                                               jg.controlSampleSheet,
                                               jg.untreatedCondition)

#Get sample names for conditions
jg.untreatedNames <- names(jg.controlCountsUntreated)
jg.treatedNames   <- names(jg.controlCountsTreated)

jg.coefficient<-jg.getNormalizationCoefficient(jg.controlCountsTreated,
                                               jg.controlCountsUntreated)
jg.correctionFactor<-jg.getCorrectionFactor(jg.experimentSampleSheet,
                                            jg.treatedNames,
                                            jg.untreatedNames)

#Apply coefficent and control factor
jg.experimentPeaksetNormalised<-jg.applyNormalisation(jg.experimentPeakset,
                                                      jg.coefficient,
                                                      jg.correctionFactor,
                                                      jg.treatedNames)
#Return values to Diffbind and plot normalised result.
jg.dba <- DiffBind:::pv.resetCounts(dbaExperiment,
                                    jg.experimentPeaksetNormalised)
jg.dba_analysis<-dba.analyze(jg.dba)

#dba.plotMA(jg.dba_analysis,bFlip=TRUE, cex.lab=1.5, cex.axis=1.5, cex.main=1.25, cex.sub=1.5)
dba_analysis<-dba.analyze(dbaExperiment)
dba.plotMA(dba_analysis,bFlip=TRUE,cex.lab=1.5, cex.axis=1.5, cex.main=1.25, cex.sub=1.5)
#Note exact numbers change depending on the machine DiffBind is run.
  

filename<-"Rdata/040_SLX-14438_dba_human_ER_CTCF.rda"
load(filename)


## Extract Peak set from DiffBind
jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)
jg.controlPeakset    <- jg.dbaGetPeakset(dbaControl)

#Convert Peakset to DeSeq Workflow
jg.controlPeaksetDeSeq<-jg.convertPeakset(jg.controlPeakset)

#Establish size factors directly from Control data
jg.controlSizeFactors = estimateSizeFactorsForMatrix(jg.controlPeaksetDeSeq)

#Get conditions dataframe for DeSeq
jg.conditions <- read.csv(file=jg.controlSampleSheet, header=TRUE, sep=",")['Condition']

#Run DeSeq on control
jg.controlDeSeq<-jg.runDeSeq(jg.controlPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.controlResultsDeseq   = results(jg.controlDeSeq)

#Repeat for experimental conditions

#Convert experiment Peakset to DeSeq Workflow
jg.experimentPeaksetDeSeq<-jg.convertPeakset(jg.experimentPeakset)

#Run DeSeq on experiment
jg.experimentDeSeq<-jg.runDeSeq(jg.experimentPeaksetDeSeq, jg.conditions,jg.controlSizeFactors)
jg.experimentResultsDeseq   = results(jg.experimentDeSeq)
dbaExperimentCorrected<-jg.correctDBASizeFactors(dbaExperiment,
                                                 jg.controlSizeFactors
                                                 )

dbaExperimentAnalysisCorrected<-dba.analyze(dbaExperimentCorrected)
  dba.plotMA(dbaExperimentAnalysisCorrected,bFlip=TRUE,cex.lab=1.5, cex.axis=1.5, cex.main=1.25, cex.sub=1.5)
  
  #Again numbers similar but not exact due to DiffBind
  
#Finally plot the same result as earlier so it is the same as in the text to generate our CTCF and linear regression figures
  dba.plotMA(jg.dba_analysis_noER,bFlip=TRUE,cex.lab=1.5, cex.axis=1.5, cex.main=1.25, cex.sub=1.5)
  
 

```
Comparison of DiffBind results before and after our two methods of normalisation. (A) Normalisation to Library Size. (B) Applying the corrected size factors from our DESeq2 pipeline generated from CTCF internal control. (C) Applying correction using linear regression of CTCF peaks between conditions to normalise data. The result is a 10.7% increase in the number of loci detected as significantly changed ER binding.

##Cross normalisation

```{r results='hide', message=FALSE, warning=FALSE, fig.cap="Comparison of fold-change of ER binding after both xenogenic and cross-normalisation. Pearson's correlation between the two methods is 0.992 (3sf, p-value tending to 0). Deviation of data points from parity is a result the integer nature of read counts, nonetheless this effect is is very small as demonstrated correlation coefficient between the two datasets."}
filename<-"Rdata/047_SLX-14438_dba_human_ER_CTCF.rda"
load(filename)


#Load Sample Ids from control sample sheet.
jg.sampleIds <- jg.getSampleIds(jg.controlSampleSheet)

## Extract Peak set from DiffBind
jg.experimentPeakset <- jg.dbaGetPeakset(dbaExperiment)
jg.controlPeakset    <- jg.dbaGetPeakset(dbaControl)


#Get counts for each condition
jg.controlCountsTreated<-jg.getControlCounts(jg.controlPeakset, 
                                             jg.controlSampleSheet,
                                             jg.treatedCondition)
jg.controlCountsUntreated<-jg.getControlCounts(jg.controlPeakset,
                                               jg.controlSampleSheet,
                                               jg.untreatedCondition)

#Get sample names for conditions
jg.untreatedNames <- names(jg.controlCountsUntreated)
jg.treatedNames   <- names(jg.controlCountsTreated)



 ##Get Normalization Coefficient
jg.coefficient<-jg.getNormalizationCoefficient(jg.controlCountsTreated,
                                               jg.controlCountsUntreated)




#As we're going to normalise a second data set we don't need to use a DiffBind correction factor
jg.correctionFactor<-1


#Apply coefficent and control factor
jg.experimentPeaksetNormalised<-jg.applyNormalisation(jg.experimentPeakset,
                                                      jg.coefficient,
                                                      jg.correctionFactor,
                                                      jg.treatedNames
)


#Return values to Diffbind object
jg.dba <- DiffBind:::pv.resetCounts(dbaExperiment,
                                    jg.experimentPeaksetNormalised
)

#jg.dba is now normalised a list of ER peaks and their expected ratio


#####
#
#Rerun the normalisation code to get the ER ratio
#
######


jg.normalisedExperimentPeakset <- jg.dbaGetPeakset(jg.dba)


#Get counts for each condition
jg.ERCountsTreated<-jg.getControlCounts(jg.normalisedExperimentPeakset, 
                                             jg.experimentSampleSheet,
                                             jg.treatedCondition)
jg.ERCountsUntreated<-jg.getControlCounts(jg.normalisedExperimentPeakset,
                                          jg.experimentSampleSheet,
                                               jg.untreatedCondition)

#Get sample names for conditions
jg.untreatedNames <- names(jg.ERCountsTreated)
jg.treatedNames   <- names(jg.ERCountsUntreated)



##Establish normalised ER ratio as we know it isn't 1

jg.ERratio<-jg.getNormalizationCoefficient(jg.ERCountsTreated,
                                               jg.ERCountsUntreated)

########
#
# Apply to ER only data
#
########

jg.EROnlyExperimentSampleSheet <- "samplesheet/samplesheet_SLX8047_hs.csv"

filename<-"Rdata/047_SLX-SLX-8047_dba_human_ER.rda"
load(filename)


#Get peakset

jg.EROnlyExperimentPeakset <- jg.dbaGetPeakset(dbaERonlyExperiment)


#Get counts for each condition
jg.EROnlyCountsTreated<-jg.getControlCounts(jg.EROnlyExperimentPeakset, 
                                            jg.EROnlyExperimentSampleSheet,
                                        jg.treatedCondition)
jg.EROnlyCountsUntreated<-jg.getControlCounts(jg.EROnlyExperimentPeakset,
                                              jg.EROnlyExperimentSampleSheet,
                                          jg.untreatedCondition)

#Get sample names for conditions
jg.untreatedNames <- names(jg.EROnlyCountsTreated)
jg.treatedNames   <- names(jg.EROnlyCountsUntreated)



jg.EROnlyExperimentRatio<-jg.getNormalizationCoefficient(jg.EROnlyCountsTreated,
                                           jg.EROnlyCountsUntreated)

#Create new ratio 
jg.ERNormalisationRatio<-jg.ERratio/jg.EROnlyExperimentRatio

g.correctionFactor<-jg.getCorrectionFactor(jg.EROnlyExperimentSampleSheet,
                                            jg.treatedNames,
                                            jg.untreatedNames
)

jg.ERexperimentPeaksetNormalised<-jg.applyNormalisation(jg.EROnlyExperimentPeakset,
                                                      jg.ERNormalisationRatio,
                                                      jg.correctionFactor,
                                                      jg.treatedNames
)

#Return values to Diffbind object
dbaERonlyExperimentNormalised <- DiffBind:::pv.resetCounts(dbaERonlyExperiment,
                                    jg.ERexperimentPeaksetNormalised
)

jg.dba_analysisNormalised<-dba.analyze(dbaERonlyExperimentNormalised)
false_postive_normalised<-dba.report(jg.dba_analysisNormalised, th=0.05)
false_postive_normalised<-length(false_postive_normalised[false_postive_normalised$Fold>0])


jg.dba_analysis<-dba.analyze(dbaERonlyExperiment)

load(file="Rdata/027_SLX-8047_dba_report.Rda")
dba.SLX8047<-dba.analyze(dba.SLX8047)

peaks<-as.character(sort(as.numeric(row.names(as.data.frame(dba.report(dba.SLX8047, th=1))))))

plot(
    dba.report(dba.SLX8047, th=1)[peaks]$Fold,
    dba.report(jg.dba_analysisNormalised,th=1)[peaks]$Fold,
    pch=20,
    xlab="Log(FoldChange) in ER Binding Normalised to H2av",
    ylab="Log(FoldChange) in ER Binding Cross-Normalised to CTCF",
    cex=0.05,
    main="Comparision of Fold-Change between\nCross-Normalised to Xenogenic Spike-in"
)
```


